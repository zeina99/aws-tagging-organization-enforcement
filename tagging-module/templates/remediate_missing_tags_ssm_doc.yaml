---
schemaVersion: '0.3'
description: "Remediate missing tags by executing Python script directly"

parameters:
  AutomationAssumeRole:
    type: String
    description: "(Required) The ARN of the IAM role that allows Automation to perform actions."
  ResourceId:
    type: String
    description: "ID of the non-compliant resource"
  DynamoDBTableArn:
    type: String
    description: "ARN of the DynamoDB table containing tag requirements"
  AccountIdKey:
    type: String
    description: "DynamoDB partition key name for account ID"
    

assumeRole: "{{ AutomationAssumeRole }}"

mainSteps:
  - name: remediateTags
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.11
      Handler: remediate_tags
      InputPayload:
        resource_id: "{{ ResourceId }}"
        account_id: "{{ global:ACCOUNT_ID }}"
        dynamodb_table_arn: "{{ DynamoDBTableArn }}"
        account_id_key: "{{ AccountIdKey }}"
        
      Script: |
        import boto3
        import json
        
        def remediate_tags(events, context):
            """Main remediation function"""
            resource_id = events['resource_id']
            account_id = events['account_id']
            ddb_table_arn = events['dynamodb_table_arn']
            account_id_key = events['account_id_key']
            
            
            print(f"Processing resource_id: {resource_id} in account: {account_id}")
            
            # Create clients using the SSM automation role (no role assumption needed)
            session = boto3.Session()
            
            # Get resource details from Resource Explorer
            resource_info = get_resource_info(session.client("config"), resource_id)
            resource_type = resource_info["resourceType"]
            # Skip if resource has no ARN (not taggable)

            if not resource_info or not resource_info.get("arn"):
                return {
                    'statusCode': 200,
                    'message': f"Skipping {resource_id} - resource is not taggable (no ARN found)"
                }
            
            arn = resource_info["arn"]
            
            print(f"Resource details - Type: {resource_type}, ARN: {arn}")
            
            # Get required tags for this account from DynamoDB
            required_tag_map = get_account_tags(account_id, ddb_table_arn, account_id_key)
            required_tag_keys = list(required_tag_map.keys())
            print(f"Required tags for account {account_id}: {required_tag_keys}")
            
            # Create tagging client
            tagging_client = session.client("resourcegroupstaggingapi")
            
            # Get current tags and determine what's missing or incorrect
            missing_keys, incorrect_keys = get_tag_differences(tagging_client, arn, required_tag_map)
            print(f"Missing tags: {missing_keys}")
            print(f"Incorrect tags: {incorrect_keys}")
            
            if not missing_keys and not incorrect_keys:
                return {
                    'statusCode': 200,
                    'message': f"No tags to remediate for {resource_id} - all required tags present with correct values"
                }
            
            # Build tag dict with missing and incorrect tags
            tags_to_apply = {key: required_tag_map[key] for key in set(missing_keys + incorrect_keys)}
            print(f"Tags to apply: {tags_to_apply}")
            
            # Apply the missing tags
            apply_tags(tagging_client, arn, tags_to_apply)
            
            return {
                'statusCode': 200,
                'message': f"Applied {len(tags_to_apply)} tags to {arn}",
                'applied_tags': tags_to_apply
            }
        def get_resource_info(config_client, resource_id):
            """Query Config to find resource details by ID"""
            query = f"SELECT resourceType, resourceId, accountId, arn WHERE resourceId = '{resource_id}'"
            
            print(f"Config query: {query}")
            
            response = config_client.select_resource_config(Expression=query)
            
            print(f"Config query results: {response.get('Results', [])}")
            
            if not response.get("Results"):
                raise Exception(f"Resource {resource_id} not found in AWS Config")
            
            result = json.loads(response["Results"][0])
            print(result)
            return result
            
        
        def get_account_tags(account_id, table_arn, account_id_key):
            """Get the required tags (key-value pairs) from DynamoDB"""
            print(f"Fetching tags from DynamoDB - Table ARN: {table_arn}, Key: {account_id_key}, Account: {account_id}")
            
            
            dynamodb = boto3.resource("dynamodb")
            table = dynamodb.Table(table_arn)
            
            try:
                resp = table.get_item(Key={account_id_key: account_id})
                item = resp.get("Item")
            except Exception as e:
                print(f"Error querying DynamoDB: {str(e)}")
                raise
            
            if not item:
                raise Exception(f"No DynamoDB entry for account {account_id}")
            
            tags = item.get("tags")
            
            if not tags:
                raise Exception(f"No 'tags' attribute found in DynamoDB for account {account_id}")
            
            # If tags is stored as a JSON string, parse it
            if isinstance(tags, str):
                tags = json.loads(tags)
            
            return tags
        
        def get_tag_differences(tagging_client, arn, required_tag_map):
            """Get current tags from resource and determine what's missing or incorrect"""
            try:
                response = tagging_client.get_resources(
                    ResourceARNList=[arn]
                )
                
                if not response.get('ResourceTagMappingList'):
                    # Resource not found or no tags - all required tags are missing
                    return list(required_tag_map.keys()), []
                
                current_tags = {
                    tag['Key']: tag.get('Value')
                    for tag in response['ResourceTagMappingList'][0].get('Tags', [])
                }
                
                missing = []
                incorrect = []
                
                for key, expected_value in required_tag_map.items():
                    if key not in current_tags:
                        missing.append(key)
                    elif current_tags[key] != expected_value:
                        incorrect.append(key)
                
                return missing, incorrect
                
            except Exception as e:
                print(f"Error getting current tags: {e}")
                # On error, assume all tags are missing to be safe
                return list(required_tag_map.keys()), list(required_tag_map.keys())
        
        def apply_tags(tagging_client, resource_arn, tags):
            """Apply tags to resource"""
            try:
                response = tagging_client.tag_resources(ResourceARNList=[resource_arn], Tags=tags)
                # Check if there were any failures
                if response.get('FailedResourcesMap'):
                    failed_resources = response['FailedResourcesMap']
                    for arn, error_info in failed_resources.items():
                        error_msg = (
                            f"Failed to tag resource {arn}: "
                            f"[{error_info['ErrorCode']}] {error_info['ErrorMessage']}"
                        )
                        print(error_msg)
                        raise Exception(error_msg)
                print(f"Successfully applied {len(tags)} tags")
            
            except Exception as e:
                print(f"Error applying tags: {e}")
                raise
    outputs:
      - Name: result
        Selector: $.Payload
        Type: StringMap
    timeoutSeconds: 300